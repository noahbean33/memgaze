-*-Mode: markdown;-*-

$Id$

-----------------------------------------------------------------------------
MemGaze Issues
=============================================================================

* The binary generated by `memgaze-inst` (instrumented binary) will
  show limited or no source line information using standard tools such
  as objdump. This is due to DynInst's rewriting format.  The
  instrumented binary, however, does contain a mapping of new
  instrumented code to code in the original binary.  The mapping can
  be read by hpcstruct (but not objdump).  As an alternative, it would
  also be possible to do the mapping with our instruction
  classification data and the line map from the original binary.

* Occasionally source-code mapping's line numbers are off. The reason
  is that DynInst occasionally lies about its mapping
  information. That is, DynInst sometimes generates extra padding
  _after_ its relocation is allegedly complete and the mapping is
  generated. See DynInst note (2) in `xlib/README.md`


-----------------------------------------------------------------------------
Directory Structure
=============================================================================

* bin-anlys: Static binary analysis and instrumentation

  - Contains code derived from MIAMI-NW. Uses DynInst.

  - Fast-footprint 'fine-grained footprint analysis' (ISPASS 20). This
    is function-level, footprint analysis combining (intraprocedural)
    static analysis, control-flow profiles (for loop execution
    counts), and memory-hit profiles.
  
  - Palm's task-based path cost analysis (critical path) for paths of
    basic blocks. Cost includes instruction pipeline latency and
    memory latency. Replaces IACA and extends its analysis.


* mem-trace: Trace or profile memory behavior

* mem-anlys: Analyze memory behavior from memory traces

  - footprint, execution interval tree

  - Palm coarse-grained footprint analysis
    palm-task: hpctoolkit run + fp analysis on database xml file


-----------------------------------------------------------------------------
Data formats
=============================================================================

* MemGaze's final trace format:

  `<insn-pc> <mem-addr> <cpu-id> <timestamp> <sample-id> <LoadModule-id>`

  - `<insn-pc>`:  instruction pointer of memory access (static, unrelocated)
  - `<mem-addr>`: memory data address (dynamic, run-time)
  - `<cpu-id>`:   core id executing instruction

  Note: In initial trace, a two-source load has two lines that are later converted to one line.


* MemCAMera trace format:

  `<insn-pc> <mem-addr> <cpu-id> <timestamp> [mem-addr2 cpu-id timestamp]`


* MemGaze's final `<binanlys file>`

  `<0:insn-pc> <1:access-class> <2:access-offset> <3:access-scale>`
  `<4:skipped-accesses> <5:symbol-offset> <6:symbol-name>`

  - <0:insn-pc>: (hex) instruction pointer of memory access *before* instrumentation, i.e., instruction pointer in original binary
  
  - <1:access-class>: (integer) access class: load class (0,1,2) or store (90)
 
  - <2:access-offset>: (hex) memory access offset <o> for an access with offsets. Consider the load: "load dest <- [src] + o", where the accessed access include <o>.
  
  - <3:access-scale>: (hex) memory access scale <k> for an access with scaling. Consider the load: "load dest <- [src1] + k [src2] + o", where the accessed access include <k>.

  - <4:skipped-accesses>: Number of skipped constant loads

  - <5:symbol-offset>: (hex) symbol offset (from section?)

  - <6:symbol-name>: (string) symbol (function) name
