-*-Mode: markdown;-*-

$Id$

-----------------------------------------------------------------------------
Libraries and build
=============================================================================

- MemGaze's dependencies are built using Spack.

  The build system leverages HPCToolkit's spack recipe. We customize
  the HPCToolkit build to use a patched DynInst (see below). The build
  now consists of a single "spack install" of HPCToolkit but built
  with a patched DynInst. The build uses a specific commit to avoid
  regression surprises.
  
  Note: The build no longer reinstalls Dyninst.


- HPCToolkit, auto-generated sources and 'develop' branch

  - We want to preserve HPCToolkit's source code tree in a
    *configured* (compilable) state, that is with the source files
    generated by autoconf.

  - Keep spack's "staged" files (--keep-stage) and then copy the needed files


- Customizations to Spack

  - config.yaml:     Update of Spack's version to change 'root' dir names
  - hpctk-pkgs.yaml: HPCToolkit's "packages.yaml"
  - dyninst.py:      Control DynInst patching. Update of Spack's version.
  - dyninst.patch:   DynInst patch


-----------------------------------------------------------------------------
Linux Perf
=============================================================================

- Intel PT works with kernel >=5.5.9, no changes needed.
  - Although we played with perf's kernel driver, we are not using it
    
- Minor patch/modification to Linux perf's user level tool for "perf script"
  - convert the dynamic ip to a static ip, to attribute to binary

- Perf examples

  - Intel PT, sampling based on loads (ptloads) or loads-and-stores
    (ptloads-stores):
  ```
  # Loads only
  perf record -m 2M,2M -o ${bin}.data
    -e intel_pt/ptw=1,branch=0,period=1,fup_on_ptw=1/u
    -e cpu/umask=0x81,event=0xd0,period=<period>,aux-sample-size=<bufsz>,call-graph=lbr/u -g
    -- <app>
    
  # For load and stores use "umask=0x83,event=0xd0"
  ```

  - Intel PT in Cycle-Accurate Mode (cf. Intel Soft Dev Manual,
    33.3.6, 33.4.2.21)
    `cyc=1,cyc_thresh=0`

  - Intel PT, sampling based on time:
  ```
  perf record -m 2M,2M -o ${bin}.data
    -e intel_pt/ptw=1,branch=0,period=1,fup_on_ptw=1/u
    -e ref-cycles/period=<period>,aux-sample-size=<bufsz>,call-graph=lbr/u -g 
    -- <app>
  ```

  - Intel PT, enabling/disabling PT instructions via hardware code filter:
  ```
  perf record -m 4M,4M -o ${bin}.data \
    -e intel_pt/ptw=1,branch=0,period=1,fup_on_ptw=1/u
    --filter 'filter @distBuildLocalMapCounters'  -- <app>
  ```

  - Intel PT, system-wide: To collect system wide, omit <app> and use -a
  ```
  perf record -a  -e <event(s)>
  ```


  - Intel Load Latency-based (sparse) data addresses:
  ```
  perf record -W -d -e cpu/mem-loads,ldlat=1,period=100/upp -- <app>
  ```


  - Use 'perf script' to extract trace from Intel PT
  ```
  perf script --script=perf-script-intel-pt.py -i <trace>
  ```
  
  - Use 'perf script' to extract trace from Intel Load Latency
  ```
  perf script --script=perf-script-intel-pt.py -i <trace>
  ```


- Check for throttling (drops):
  `perf report -D | grep THROTTLE`


- Interpreting 'time stamps' within trace

  We use ref-cycles as opposed to the task-clock or the cpu-clock. The
  benefits of ref-cycles are seen especially when monitoring
  multi-threaded tasks or system-wide. (Cf. `perf record -k/--clockid`)

  - task-clock: Software clock that on context switch, does not count
    when task blocks

  - cpu-clock: Software clock that is attached to the cpu and not
    task. (cpu-clock can be used to count time between context
    switches.)
  
  - ref-cycles: hardware clock that follows task. Ticks at the fixed,
    tsc rate (but does stop when cpu goes in low power). The tsc is
    synchronized acrross all cores.
  
  Note: when using -a, ensure using ref-cycles!


- Other notes:

  - Call paths: On our Atom-based (J5005) test machine, it appears
    that collecting call paths using LBR is not supported. Therefore,
    '-g' defaults to libunwind. libunwind occurs in user-space and
    perf copies context/stack into its buffer.

  - With perf's --per-thread there is a data file per cpu.
   
  - Without --per-thread, perf opens a fd on each core because it has
    a buffer/event per cpu (default size is 129 pages @ 4k each page)
    
  - Internal perf driver: Can use 'perf-event-enable/disable" (ioctl)
    to enable/disable a perf event.


-----------------------------------------------------------------------------
DynInst
=============================================================================

https://github.com/dyninst/


1. DynInst not not generate source-line mapping for new instrumented
   code but *does* generate a mapping of the new instrumentation to
   the insertion point in the original binary. This mapping enables a
   tool to associate new instrumentation to original source code.

   DynInst does *not* currently generate the mapping using official
   DWARF. The format *can* be read via SymTabAPI. Consequently,
   hpcstruct can exploit it (using SymTabAPI), but standard tools like
   objdump and readelf cannot.
   

2. MemGaze needs the mapping of each new ptwrite (instrumentation) to
   the original memory access instruction. Not only does this provide
   source line information, but it is also needed for the
   memory-access class (e.g., load classes) associated with a given
   ptwrite instrumentation.

   Further, MemGaze's instrumentation has been designed to never
   require that registers be saved or restored, i.e., spill code.
   Consequently, DynInst should never insert spill code!

   There are two DynInst issues.

   First, DynInst has no interface for the desired mapping.
   Consequently, we currently apply a hack/patch to print it for
   MemGaze's consumption.
   
   Second, for an unknown reason, DynInst sometimes inserts
   unnecessary spill code. Further, the spill code is added *after*
   the mapping of new instrumentation to original code is generated!
   
   As an aside, it is important to note that the resolution of the
   mapping is the basic-block level rather than per-instruction. The
   basic-block mapping is typically sufficient to obtain an
   instruction level one as long as the order of instrumented
   instructions does not change. MemGaze does not change ordering.

   The two problems above have two results. First, it adds time
   overhead to instrumented code. Second, it means that DynInst's
   mapping of new instrumentation to original code is wrong.

   Possible workarounds: Re-run MemGaze's static binary analysis on
   the new code within the binary.

   Following is an example of the spill code. (Yasodha was able to
   consistently reproduce this for AMG and HiParTI-matrix COO.)
     ```
     105ddf: 48 8d 64 24 80                lea    -0x80(%rsp),%rsp
     105de4: 50                            push   %rax
     105de5: 9f                            lahf
     105de6: 0f 90 c0                      seto   %al
     105de9: 50                            push   %rax
     105dea: f3 48 0f ae e6                ptwrite %rsi            <==
     105def: 58                            pop    %rax
     105df0: 80 c0 7f                      add    $0x7f,%al
     105df3: 9e                            sahf
     105df4: 58                            pop    %rax
     105df5: 48 8d a4 24 80 00 00          lea    0x80(%rsp),%rsp
     ```

   Following are some details on the mapping hack and spill code:

   - Print the original to relocated address at following function 
       `dyninstAPI/src/binaryEdit.C ->  490 bool BinaryEdit::writeFile(...)`
  
     while it is building dyninst symbols:

       `805 void BinaryEdit::buildDyninstSymbols(...)`

   - After that point DynInst starts writing the binary with following call path:
       ```
       in  dyninstAPI/src/binaryEdit.C
         675 if (!symObj->emit(newFileName.c_str())) {

       in symtabAPI/src/Symtab.C
         2213 SYMTAB_EXPORT bool Symtab::emit(..)
         2199 SYMTAB_EXPORT bool Symtab::emitSymbols(...)
           in here it is adding static and dynamic symbols to all symbols

       in symtabAPI/src/Object-elf.C
         3290 bool Object::emitDriver(...)
           in here it calls create symbol table function
           -> in symtabAPI/src/emitElf.C
               1640 bool emitElf<ElfTypes>::createSymbolTables()
                 this fuction creates the final symbolTables 
       ```

     Ozgur thinks extra padding is happening here.
       ```
       1730    Offset lastRegionAddr = 0, lastRegionSize = 0;
       1731    vector<Region *>::iterator newRegIter;
       1732    for (newRegIter = newRegs.begin(); newRegIter != newRegs.end();
       1733         ++newRegIter) {
       1734        if ((*newRegIter)->getDiskOffset() > lastRegionAddr) {
       1735            lastRegionAddr = (*newRegIter)->getDiskOffset();
       1736            lastRegionSize = (*newRegIter)->getDiskSize();
       1737        }
       1738    }
       ```
     After that it will emit to the new file.
